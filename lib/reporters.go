package vegeta

import (
	"encoding/json"
	"fmt"
	"io"
	"sort"
	"strconv"
	"strings"
	"text/tabwriter"
)

// Reporter represents Result reporters that can write reports to an io.Writer
// and a add new Results as they come.
type Reporter interface {
	Report(io.Writer) error
	Add(Result)
}

// Summarizer represents data structures which can compute expensive
// derived summary metrics based on previous computed state.
type Summarizer interface {
	Summarize()
}

// Report decodes Results with the given Decoder to write to out the report
// generated by the given Reporter every window Results decoded.
// It returns an error in case of failure reading or writing.
func Report(dec Decoder, rep Reporter, out io.Writer, window uint64) (err error) {
	var (
		r Result
		n uint64
	)

	sum, ok := rep.(Summarizer)
	for {
		if err = dec(&r); err != nil {
			if err == io.EOF {
				break
			}
			return err
		}

		rep.Add(r)
		n++

		if n%window == 0 {
			if ok {
				sum.Summarize()
			}
			if err = rep.Report(out); err != nil {
				return err
			}
		}
	}

	if n%window != 0 {
		if ok {
			sum.Summarize()
		}
		return rep.Report(out)
	}

	return nil
}

// HistogramReporter is a Reporter that computes and writes out a Histogram as
// aligned, formatted text.
type HistogramReporter struct{ Histogram }

// Report partially implements the Reporter interface.
func (r HistogramReporter) Report(w io.Writer) error {
	tw := tabwriter.NewWriter(w, 0, 8, 2, ' ', tabwriter.StripEscape)
	fmt.Fprintf(tw, "Bucket\t\t#\t%%\tHistogram\n")
	for i, count := range r.Counts {
		ratio := float64(count) / float64(r.Total)
		lo, hi := r.Buckets.Nth(i)
		pad := strings.Repeat("#", int(ratio*75))
		fmt.Fprintf(tw, "[%s,\t%s]\t%d\t%.2f%%\t%s\n", lo, hi, count, ratio*100, pad)
	}
	return tw.Flush()
}

// TextReporter is a Reporter that computes and writes out Metrics as aligned,
// formatted text.
type TextReporter struct{ Metrics }

// Report partially implements the Reporter interface.
func (r TextReporter) Report(w io.Writer) (err error) {
	const fmtstr = "Requests\t[total, rate]\t%d, %.2f\n" +
		"Duration\t[total, attack, wait]\t%s, %s, %s\n" +
		"Latencies\t[mean, 50, 95, 99, max]\t%s, %s, %s, %s, %s\n" +
		"Bytes In\t[total, mean]\t%d, %.2f\n" +
		"Bytes Out\t[total, mean]\t%d, %.2f\n" +
		"Success\t[ratio]\t%.2f%%\n" +
		"Status Codes\t[code:count]\t"

	tw := tabwriter.NewWriter(w, 0, 8, 2, ' ', tabwriter.StripEscape)
	if _, err = fmt.Fprintf(tw, fmtstr,
		r.Requests, r.Rate,
		r.Duration+r.Wait, r.Duration, r.Wait,
		r.Latencies.Mean, r.Latencies.P50, r.Latencies.P95, r.Latencies.P99, r.Latencies.Max,
		r.BytesIn.Total, r.BytesIn.Mean,
		r.BytesOut.Total, r.BytesOut.Mean,
		r.Success*100,
	); err != nil {
		return err
	}

	for code, count := range r.StatusCodes {
		if _, err = fmt.Fprintf(tw, "%s:%d  ", code, count); err != nil {
			return err
		}
	}

	if _, err = fmt.Fprintln(tw, "\nError Set:"); err != nil {
		return err
	}

	for _, e := range r.Errors {
		if _, err = fmt.Fprintln(tw, e); err != nil {
			return err
		}
	}

	return tw.Flush()
}

// JSONReporter is a Reporter that computes and writes out Metrics as JSON.
type JSONReporter struct{ Metrics }

// Report partially implements the Reporter interface.
func (r JSONReporter) Report(w io.Writer) error {
	return json.NewEncoder(w).Encode(r.Metrics)
}

// PlotReporter is a Reporter that aggregates Results and writes a self-contained
// HTML page with an interactive plot of the latencies of Requests, built with
// http://dygraphs.com/
type PlotReporter struct{ Results }

// Report partially implements the Reporter interface.
func (r PlotReporter) Report(w io.Writer) (err error) {
	sort.Sort(r.Results)

	_, err = fmt.Fprintf(w, plotsTemplateHead, asset(dygraphs), asset(html2canvas))
	if err != nil {
		return err
	}

	buf := make([]byte, 0, 128)
	for i, result := range r.Results {
		buf = append(buf, '[')
		buf = append(buf, strconv.FormatFloat(
			result.Timestamp.Sub(r.Results[0].Timestamp).Seconds(), 'f', -1, 32)...)
		buf = append(buf, ',')

		latency := strconv.FormatFloat(result.Latency.Seconds()*1000, 'f', -1, 32)
		if result.Error == "" {
			buf = append(buf, "NaN,"...)
			buf = append(buf, latency...)
			buf = append(buf, ']', ',')
		} else {
			buf = append(buf, latency...)
			buf = append(buf, ",NaN],"...)
		}

		if i == len(r.Results)-1 {
			buf = buf[:len(buf)-1]
		}

		if _, err = w.Write(buf); err != nil {
			return err
		}

		buf = buf[:0]
	}

	_, err = w.Write([]byte(plotsTemplateTail))
	return err
}

const (
	plotsTemplateHead = `<!doctype html>
<html>
<head>
  <title>Vegeta Plots</title>
</head>
<body>
  <div id="latencies" style="font-family: Courier; width: 100%%; height: 600px"></div>
  <button id="download">Download as PNG</button>
  <script>%s</script>
  <script>%s</script>
  <script>
  new Dygraph(
    document.getElementById("latencies"),
    [`
	plotsTemplateTail = `],
    {
      title: 'Vegeta Plot',
      labels: ['Seconds', 'ERR', 'OK'],
      ylabel: 'Latency (ms)',
      xlabel: 'Seconds elapsed',
      showRoller: true,
      colors: ['#FA7878', '#8AE234'],
      legend: 'always',
      logscale: true,
      strokeWidth: 1.3
    }
  );
  document.getElementById("download").addEventListener("click", function(e) {
    html2canvas(document.body, {background: "#fff"}).then(function(canvas) {
      var url = canvas.toDataURL('image/png').replace(/^data:image\/[^;]/, 'data:application/octet-stream');
      var a = document.createElement("a");
      a.setAttribute("download", "vegeta-plot.png");
      a.setAttribute("href", url);
      a.click();
    });
  });
  </script>
</body>
</html>`
)
