package vegeta

import (
	"encoding/gob"
	"io"
	"time"
)

func init() {
	gob.Register(&Result{})
}

// Result represents the metrics defined out of an http.Response
// generated by each target hit
type Result struct {
	Code      uint16        `json:"code"`
	Timestamp time.Time     `json:"timestamp"`
	Latency   time.Duration `json:"latency"`
	BytesOut  uint64        `json:"bytes_out"`
	BytesIn   uint64        `json:"bytes_in"`
	Error     string        `json:"error"`
}

// End returns the time at which a Result ended.
func (r *Result) End() time.Time { return r.Timestamp.Add(r.Latency) }

// Add partially implements the Reporter interface.
func (r *Result) Add(other Result) { *r = other }

// Results is a slice of Results.
type Results []Result

// Add partially implements the Reporter interface.
func (rs *Results) Add(r Result) { *rs = append(*rs, r) }

// The following methods implement sort.Interface
func (rs Results) Len() int           { return len(rs) }
func (rs Results) Less(i, j int) bool { return rs[i].Timestamp.Before(rs[j].Timestamp) }
func (rs Results) Swap(i, j int)      { rs[i], rs[j] = rs[j], rs[i] }

// A Decoder decodes a Result and returns an error in case of failure.
type Decoder func(*Result) error

// NewDecoder returns a new Result decoder closure for the given io.Readers.
// It round robins across the io.Readers on every invocation and decoding error.
func NewDecoder(readers ...io.Reader) Decoder {
	dec := make([]*gob.Decoder, len(readers))
	for i := range readers {
		dec[i] = gob.NewDecoder(readers[i])
	}
	var seq uint64
	return func(r *Result) (err error) {
		for range dec {
			robin := seq % uint64(len(dec))
			seq++
			if err = dec[robin].Decode(r); err != nil {
				continue
			}
			return nil
		}
		return err
	}
}

// An Encoder encodes a Result and returns an error in case of failure.
type Encoder func(*Result) error

// NewEncoder returns a new Result encoder closure for the given io.Writer
func NewEncoder(r io.Writer) Encoder {
	enc := gob.NewEncoder(r)
	return func(r *Result) error {
		return enc.Encode(r)
	}
}
